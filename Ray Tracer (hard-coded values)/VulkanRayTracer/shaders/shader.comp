#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WINDOW_WIDTH 500
#define WINDOW_HEIGHT 500
#define WORKGROUP_SIZE 32

layout (local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1 ) in;

struct Pixel {
    vec4 value;
};

layout(binding = 0) buffer buf
{
    Pixel imageData[];
};

// START - Camera values and functions
struct Camera {
    vec3 position;
    vec3 lookAt;
    vec3 up;
    float focalLength; // between 0 and 1
};

Camera createCamera(vec3 position, vec3 lookAt, vec3 up, float focalLength) {
    Camera cam;
    cam.position = position;
    cam.lookAt = lookAt;
    cam.up = up;
    cam.focalLength = focalLength;
    return cam;
}

// Camera To World Matrix == inverse of view matrix
// Transforms from camera-view to world-view
mat4 cameraToWorldMatrix(Camera cam) {
    // Below is the view matrix, need to invert it

    // right-handed coordinate system
    // Note that camera space matches OpenGL convention:
    // camera's forward is the negative Z axis.
    vec3 pos = cam.position;
    vec3 zaxis = normalize(pos - cam.lookAt); // The "forward" vector.
    vec3 xaxis = normalize(cross(cam.up, zaxis));  // The "right" vector.
    vec3 yaxis = cross(zaxis, xaxis);       // The "up" vector.

    mat4 matrix = {
        vec4(           xaxis.x,            yaxis.x,            zaxis.x,  0 ),
        vec4(           xaxis.y,            yaxis.y,            zaxis.y,  0 ),
        vec4(           xaxis.z,            yaxis.z,            zaxis.z,  0 ),
        vec4(-dot( xaxis, pos ), -dot( yaxis, pos ), -dot( zaxis, pos ),  1 )
    };

    return inverse(matrix);
}

// END - Camera values and functions


// START - Ray values and functions
struct Ray {
    vec3 origin;
    vec3 direction;
};

Ray CreateRay(vec3 origin, vec3 direction) {
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray createCameraRay(Camera cam, vec2 uv) {
    mat4 cameraToWorld = cameraToWorldMatrix(cam);

    // Transform the camera origin to world space
    vec3 origin = (cameraToWorld * vec4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;

    // Consider direction at uv with z being the camera's focal length
    vec3 direction = vec3(uv, cam.focalLength);

    // Transform the direction from camera to world space and normalize
    direction = (cameraToWorld * vec4(direction, 0.0f)).xyz;
    direction = normalize(direction);
    return CreateRay(origin, direction);
}
// END - Ray values and functions

void main() {
    /* In order to fit the work into workgroups, some unnecessary threads are launched.
    We terminate those threads here. */
    if(gl_GlobalInvocationID.x >= WINDOW_WIDTH || gl_GlobalInvocationID.y >= WINDOW_HEIGHT) {
        return;
    }

    // Transform pixel to [-1,1] range
    float x = 2.0f * float(gl_GlobalInvocationID.x) / float(WINDOW_WIDTH) - 1.0f;
    float y = 2.0f * float(gl_GlobalInvocationID.y) / float(WINDOW_HEIGHT) - 1.0f;

    Camera cam = createCamera(vec3(0,0,0), vec3(0,-1,0), vec3(0,0,1), 0.5f);
    Ray ray = createCameraRay(cam, vec2(x, y));

    imageData[WINDOW_WIDTH * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x].value = vec4(ray.direction, 1.0);
}
